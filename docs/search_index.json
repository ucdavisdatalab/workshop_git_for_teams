[["index.html", "Reproducible Research for Teams with GitHub Overview", " Reproducible Research for Teams with GitHub Tyler Shoemaker Carl Stahmer 2022-10-21 Overview GitHub is an online platform for software development using Git for version control. During this hands-on workshop we’ll practice setting up, sharing, and collaboratively working on a repository for a research project. We’ll explore different features for improving your workflows, whether you’re working by yourself or with others on a data-driven project using GitHub. "],["preliminaries.html", "1 Preliminaries 1.1 Interactive Session Information 1.2 About this Tutorial 1.3 Objectives for this Workshop 1.4 Prerequisites", " 1 Preliminaries This workshop covers the basics of using Git in tandem with GitHub. It is a hybrid workshop. First, independently work through this online tutorial at your own pace and ensure that you have set up GitHub account. Next, join us for the live interactive session (details below), during which we will learn how to use GitHub to sync local and remote repositories, manage code, and work in parallel with teams. If you need help troubleshooting your installation, drop-in to DataLab’s virtual office hours prior to the interactive session to ensure that you will be able to follow along on your own machine. The full workshop description can be found here. 1.1 Interactive Session Information The workshop includes a live, interactive session. Zoom login information will be sent to all registered participants via email; reach out to datalab-training@ucdavis.edu the day prior if you received a registration confirmation but have not received your Zoom link. 1.2 About this Tutorial This online tutorial provides background information that will help participants to better understand the concepts introduced during the interactive session. It also includes information to help you successfully set up a GitHub account, which must be completed prior to the interactive session. 1.3 Objectives for this Workshop By the end of this workshop, learners will be able to: Push local changes to a repository on GitHub Create a local copy of an existing repository from GitHub Open and merge a pull request Create a branch to manage work in parallel Add issues and manage notifications for a GitHub repository Identify where to go to learn more 1.4 Prerequisites Familiarity with Command Line and Git version control software is required. Participants should be proficient in navigating their machine and executing basic Git commands using a shell scripting program (Terminal, Bash, etc.). Before attending this workshop, learners should be able to create, modify and navigate to a directory, place a directory under version control, and make, stage and commit changes using Command Line. Need to brush up? Preparatory workshops include DataLab’s Introduction to Command Line and Introduction to Git for Version Control (See materials at https://datalab.ucdavis.edu/workshops/). "],["about-github.html", "2 About GitHub 2.1 The Basics 2.2 Communicating Through GitHub 2.3 What Should I Push to GitHub?", " 2 About GitHub 2.1 The Basics At its simplest, GitHub is a hosting service for Git repositories. Much like Dropbox or Google Drive, it gives you a space to remotely store your code and related files. This can be useful when working on projects that require, for example, some kind of server, whether for the purposes of running large, potentially time-consuming data analyses or for serving up public-facing content (like a website). For such projects, GitHub acts as a reference point with which you can add, or push, changes on one computer and bring them down, or pull them, onto another. The process would look something like the following, where pushing and pulling from a remote branch entails keeping a reference point for a project that you’re developing locally: Image source. With this diagram in mind, it’s not much of a conceptual leap to imagine how two or more people could work from the same remote repository. Each would pull that repository onto their respective local computers, make a branch, implement their changes, and push those changes back to the remote source. That way, multiple parts of a project could be under development simultaneously, and any such changes made to that project would be trackable according to the logic of version control. Simultaneously pushing and pulling on multiple computers would look something like the following: Image source. 2.2 Communicating Through GitHub So far, however, this whole process could be implemented with other version control software. What makes GitHub special is the fact that, more than being simply a place to store files, the service is above all a communication channel. Where GitHub extends the functionality of version control is not just where it offers various forms of cloud hosting; it is also where GitHub provides tools that let people talk about the code they’re working on. It’s a place where team members can propose and explain the changes they make, look at changes others have made, track and discuss any bugs that might come up, get feedback from others, and plan for any future changes the team intends to make. Learning how to use GitHub, then, is as much about learning how to communicate effectively through the different facets of the service as it is about acquainting yourself with new technical skills (i.e., using your computer to track code remotely). In this workshop, we’ll discuss both parts of using the service and do so with an eye toward how GitHub can facilitate team science. A short summary of the different facets of communication GitHub provides includes: Documentation, often through README files Issue tracking for bug reporting and assigning tasks Pull requests for proposing and discussing changes Wikis, which may feature additional documentation, tutorials, etc. Project boards for long-term planning Various graph visualizations for project overview Additionally, GitHub users can monitor and modify other projects’ code using “Watch”, “Star”, and “Fork” functionalities. The service also provides teams with the ability to specify licensing information for their projects. 2.3 What Should I Push to GitHub? A quick word about what should and shouldn’t be pushed to a remote repository, especially with an eye toward what we’ve said about communication. You can, of course, host large data files on GitHub, but there are a few caveats. For one, the site does have a storage limit, and it can also become quite inefficient to have team members constantly push/pull large files to/from GitHub. Further, hosting data files might not be particularly relevant to what a team might need to discuss. Data may change often over the course of a project, but tracking individual observations might not be necessary—more meaningful would be a conversation about how code has made, or might make, such changes. The latter is likely to be something that GitHub is better suited to facilitate. It’s best, then, to host your data files separately from GitHub, either by way of a remote database or some kind of cloud service like Google Drive. Exceptions may come up, however, so the decision about what to track should ultimately be one made by the team. Examples of what should be tracked with GitHub: Code Documentation Make files Some supporting media (small images, for example) Finally, note that even though you can set a repository to either “Public” or “Private” (which controls who can see your project), it’s recommended that you refrain from uploading various access credentials (API keys, database passwords, etc.) to GitHub. "],["setting-up-a-github-account.html", "3 Setting Up a GitHub Account 3.1 Basic GitHub Account Setup 3.2 GitHub Desktop, or the Command Line? 3.3 Locally Setting Up Your Git Credentials 3.4 SSH Keys and GitHub 3.5 Connecting to GitHub with SSH", " 3 Setting Up a GitHub Account 3.1 Basic GitHub Account Setup To use GitHub, you need to make a (free) account. You can do so by going to github.com. Once you’re there, click “Sign Up” in the top-right corner of the page. This should take you to a form, which asks you to enter a username, email address, and password. After you’ve entered in this information (and completed a quick CAPTCHA), GitHub will make you an account. Then, the site will prompt you to complete an optional survey. Fill it out, or scroll to the bottom to skip it. Either way, you’ll need to then verify your email address. Go to your inbox and look for an email from GitHub. Click the “Verify email address” button. Doing so will take you to your homepage, where, if you’d like, you can add a few details about yourself. You now have a GitHub account! 3.2 GitHub Desktop, or the Command Line? Remember that Git is separate from GitHub. The latter is a service that’s been built around the former. One part of the services that GitHub offers is an application called GitHub Desktop, which allows users to manage their local repositories with a point-and-click graphical user interface (or GUI). Ultimately, it’s a matter of preference whether you use the GUI or stick with the command line for your own projects, but for this workshop, we will mostly interact with GitHub via the command line. One of the primary reasons for this has to do with the fact that not every computer you use will have GitHub’s GUI installed—or even have a screen! Many remote servers offer command line-only access, and if you ever want to sync your files with these machines, you’ll need to do so without GitHub Desktop. Luckily, GitHub seamlessly extends Git commands, so using the service without the GUI is, as we’ll see, quite straightforward. 3.3 Locally Setting Up Your Git Credentials Regardless of how you make your commits, you will need to use the command line to provide Git with some information about who will be making commits. You may have already done this, however (and sometimes your computer does it automatically). To check, enter the following two commands in either Terminal (Mac) or Git Bash (Windows): $ git config --global user.name $ git config --global user.email If you see your name (or some kind of username) and your email after entering the above commands, you’re set. If nothing happens when you type them, you’ll need to provide this information with the following: $ git config --global user.name &quot;&lt;your name&gt;&quot; $ git config --global user.email &quot;&lt;your email&gt;&quot; You can check whether this was successful by simply calling either, or both, of the first two commands. They should echo back the information you’ve just entered. 3.4 SSH Keys and GitHub When you work with remote repositories on GitHub, you’ll often need to enter your username/password to identify yourself. This is for two reasons: 1) it allows GitHub to track who has made changes to what files; 2) it adds a layer of security to projects, letting teams control who can make changes to their files. Repositories can be either public or private, and this layer of security helps teams control who has access to files in the first place. It can be a pain, though, to have to enter and re-enter your credentials when making changes. More, passwords can be lost or worse, stolen. To avoid these problems, we can set up an SSH key. SSH keys (short for “Secure Shell”) are special, machine-readable credentials that allow users to safely connect and authenticate with remote servers over unsecure networks. An SSH key has two parts: A public key, which encrypts messages intended for a particular recipient. This can be stored on remote servers, or even shared with others, to facilitate secure data transfers A private key, which deciphers messages encrypted by the public key. Your private key is the only thing capable of unlocking what is sent with your public key. It stays on your computer and should never be shared with anyone Beyond what security measures an SSH key brings, it also acts as your digital signature. GitHub uses this internally to verify that you are, in fact, who you say you are when you commit code to a repository. 3.5 Connecting to GitHub with SSH GitHub offers thorough, straightforward documentation for setting up an SSH key with its services, which we won’t repeat here. Instead, please visit the link below and follow the step-by-step instructions there to get yourself set up with a key. We will not go through this process during the workshop, so you must complete it before the session. Connecting to GitHub with SSH The following steps at the link above are required: Checking for existing SSH keys Generating a new SSH key and adding it to the ssh-agent Adding a new SSH key to your GitHub account Testing your SSH connection Once you have completed these steps, be sure you can successfully run the following command: $ ssh -T git@github.com If your connection is successful, you will see this message (a warning may first appear—see the documentation on GitHub for more information): Hi &lt;your username&gt;! You&#39;ve successfully authenticated, but GitHub does not provide shell access. Need help? DataLab offers weekly open office hours sessions. Check the DataLab Calender for specific dates and times. "],["pushing-a-repository.html", "4 Pushing a Repository 4.1 Making a Test Repository 4.2 Preparing to Sync Your Repository 4.3 Pushing a Local Repository 4.4 Tracking Files Remotely 4.5 Pulling Changes from a Remote Directory 4.6 Keeping Certain Files Untracked", " 4 Pushing a Repository Now that you’re all set up with GitHub, it’s time to sync the website with a local repository on your computer. 4.1 Making a Test Repository First, use the command line to make a new directory in your Home folder: $ mkdir ~/my_first_remote_directory Put this directory under version control with Git: $ cd ~/my_first_remote_directory $ git init Initialized empty Git repository in &lt;path&gt;/&lt;to&gt;/my_first_remote_directory/.git/ Now let’s create a new file, called: $ echo &#39;Hello world!&#39; &gt; README.md Time to add and commit our file with Git. Don’t forget to write a short note in the commit message. $ git add README.md $ git commit -m &#39;Added a README file&#39; main (root-commit) cad7867] Added a README file 1 file changed, 1 insertion(+) create mode 100644 README.md 4.2 Preparing to Sync Your Repository So far so good! All we’ve done is repeat the normal workflow for putting files under version control. But now we need to step away from the command line for a moment and prepare a space for receiving this repository on GitHub. To do so, go to github.com and, on your homepage, click the “Create repository” button. You’ll be taken to this page: There are a few things of note here: Repository name: your repository’s name, which should be the same as what’s on your computer Description: a short (1-2 sentence) explanation of what’s in this repository Public/private setting: repositories may be either “public” (viewable by anyone) or “private” (only viewable by you and those to whom you grant access) Initialize with details, including: A README file: a form of documentation; provides information about the files in the repository A .gitignore file: instructs Git to ignore specific files or filetypes A license: governs the use or redistribution of your files Because we’re initializing this repository from an existing directory, we won’t bother with most of the extra details. But we do need a title, which should be the same as what’s on your local computer (my_first_remote_directory). A description is helpful but not necessary for our purposes; the same goes for a license. Finally, we will choose to make this a public repository (meaning anyone can see it). 4.3 Pushing a Local Repository Once you’ve entered the above information, click “Create repository.” GitHub will take you to a new screen, which gives you a number of options for making or uploading new files to the repository. Since we already have a repository made, we need to use the “Push an existing repository from the command line.” Pushing our repository is as easy as sequentially entering into the command line the three commands GitHub provides. $ git remote add origin git@github.com:&lt;your username&gt;/my_first_remote_directory.git $ git branch -M main $ git push -u origin Enumerating objects: 3, done. Counting objects: 100% (3/3), done. Writing objects: 100% (3/3), 239 bytes | 239.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:&lt;your username&gt;/my_first_remote_directory.git * [new branch] main -&gt; main Branch &#39;main&#39; set up to track remote branch &#39;main&#39; from &#39;origin&#39;. To summarize the above, we’ve done the following: Associated GitHub’s remote repository with our local repository (git remote etc.) Made a new branch in our local repository called “main” (git branch -M main) Pushed the contents of main (from origin) to a new, corresponding remote branch on GitHub From here on out, when you want to update the remote repository with further changes, you can simply use the shorthand git push after the usual save, add, commit steps. Importantly, Git will only update the branch you’re on when you enter git push, so before making any pushes, it’s a good idea to run a quick git status command to make sure you’re on the branch you want to be on. When you make your changes, the GitHub site won’t immediately refresh itself, but if you click on the “Code” tab or on the name of the directory, you’ll see that the repository has been synced and your README.md file is now online. Note that GitHub automatically looks for a README file in your repository. If it finds one that contains renderable markdown code, it will render the file on your repository’s main page. (More information about writing effective README files is available through the DataLab’s data documentation workshop.) 4.4 Tracking Files Remotely With this repository made, GitHub can start tracking changes you make to your files, much as Git does locally. The process works exactly like the one you do for Git, though it requires one more step. First, we’ll alter our README.md. Reopen the file with Vim, skip a line down from the line you’ve already written, and add “My name is .” Save and quit. Your file should look like the following: $ cat README.md Hello world! My name is &lt;your name&gt;. Then, add the file and commit your changes. $ git add README.md $ git commit -m &#39;Added my name to README&#39; [main 78bf509] Added my name to README 1 file changed, 2 insertions(+) If you want to push these changes to your remote repository, simply enter git push. Just as when you first linked your local repository to GitHub, you’ll see a message appear about enumerating, counting, and writing objects. $ git push Enumerating objects: 5, done. Counting objects: 100% (5/5), done. Writing objects: 100% (3/3), 292 bytes | 292.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 To github.com:&lt;your username&gt;/my_first_remote_directory.git cad7867..78bf509 main -&gt; main Afterwards, if you refresh your file’s page on GitHub, you should see your changes: Note that your commit message appears here as well: If you click the commit tag: You’ll be taken to another page, which shows you the differences between your old version and the new one. This is like running git diff &lt;commit a&gt; &lt;commit b&gt; on your local computer. 4.5 Pulling Changes from a Remote Directory Before moving on, it’s also worth noting that we can pull changes directly from GitHub. If a file has been altered on the remote version of a project, GitHub offers functionality for syncing that file with your local copy (or creating a new file altogether, if need be). For example, if you return to the main page of “my_first_remote_directory”, you can alter the README directly on GitHub. Click the pencil in the right-hand corner of the rendered file. This will open up a text editor interface. Using it, add “What’s yours?” on the fifth line of the document. The complete document should look like this: Hello world! My name is &lt;your name&gt; What&#39;s yours? Scroll to the bottom and click the green “Commit changes” button. This is the equivalent of doing git add &lt;file&gt; and git commit -m &lt;message&gt; on the command line. You’ll see something like the following: Back on the command line, you can run git fetch to see whether any changes have been made to the remote repository. $ git fetch remote: Enumerating objects: 5, done. remote: Counting objects: 100% (5/5), done. remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (3/3), 666 bytes | 333.00 KiB/s, done. From github.com:t-shoemaker/my_first_remote_directory 78bf509..2335530 main -&gt; origin/main With this information about your remote repository pulled down to your computer, you can run a status check. If you do so, you’ll see that your local repository is now out of sync with the remote one. $ git status On branch main Your branch is behind &#39;origin/main&#39; by 1 commit, and can be fast-forwarded. (use &quot;git pull&quot; to update your local branch) nothing to commit, working tree clean If you haven’t made any changes to your directory, syncing it with the remote version can be achieved with a straightforward pull command: $ git pull Updating 78bf509..2335530 Fast-forward README.md | 2 ++ 1 file changed, 2 insertions(+) Your files are now synced. A later portion of this reader will discuss how to handle this process when you have made changes to your directory between the time the remote was altered and the time you go to make a pull. 4.6 Keeping Certain Files Untracked Before moving on, let’s briefly consider files that you don’t want Git/GitHub to track. When you’re using remote repositories, you’ll often find yourself in situations where you don’t want to share certain things with everyone who might come across your repository. Information about your system configuration, passwords, or other sensitive data are all examples of things you shouldn’t push to GitHub. Most modern operating systems (such as Mac or Windows) also automatically create and store a lot of hidden configuration files within the computer’s directory structure. For example, below is a file listing for a directory containing resources for a workshop the DataLab offers about text mining and R: $ ls D3VIS data gephi_tutorial kumu_tutorial r_networks readme.txt scraping text_mining And here is the same directory listing showing hidden files: $ ls -a . .DS_Store D3VIS gephi_tutorial r_networks scraping .. .git data kumu_tutorial readme.txt text_mining Note the appearance of the previously hidden .DS_Store and .git directories when we run ls -a. These are those system- and directory-specific configuration files. Git is pretty smart, and it knows to ignore its own hidden configuration files, but we need to tell it explicitly to ignore the other one using a special file called .gitignore. You can create a .gitignore file from scratch using Vim by typing vim .gitignore on the command line. When you do this, Vim will open a new file. Then, you simply add the names of files and directories that you want Git to ignore, putting one per line of the new file. .httr-oauth .DS_Store .config data/* Note in this example that we’ve also added the data folder and any of its contents to .gitignore. This is for two reasons, which we discussed earlier: 1) it’s generally bad practice to track data files with version control systems; 2) the free version of GitHub (which you’re probably using) puts a cap on the total size of a repository. It would be a waste of space to have data eating away at that size limit. Generally speaking, you should place your .gitignore file in the root of your repository, where it will control Git behavior for the repository. You can create a global .gitignore file, but this requires you to run various system configurations on Git itself. Information on this process can be found here. GitHub also provides a nice repository of template .gitignore files for various types of development here. "],["cloning-a-repository.html", "5 Cloning a Repository 5.1 Cloning 5.2 Branching", " 5 Cloning a Repository While tracking your own files remotely with GitHub is great for managing and storing your files, this doesn’t quite tap into the full use of the service. Remember, GitHub is above all a communication channel, in which people can share and discuss the code/files they’re working on. We haven’t yet taken advantage of much of what makes GitHub useful: getting files for a project, modifying them, discussing the changes with team members, and implementing those changes. 5.1 Cloning To start using GitHub collaboratively, we need to retrieve, or clone, a repository. This will create a local copy of project files. First, go back to your Home directory. You’ll be putting a repository here (in command line speak, the repository will be a “child” of Home). $ cd ~ Now go to the following link: https://github.com/ucdavis-datalab-training/workshop_git_for_teams_sandbox Once there, click on the green “Code” button, which should show the following: Since you have SSH keys, select the “SSH” option. Copy the text GitHub provides to your clipboard. Then, in the command line, type git clone, add a space, and paste in the line of text GitHub generated for you. Press Enter when you’ve entered this information. The full command should look like this: $ git clone git@github.com:ucdavis-datalab-training/workshop_git_for_teams_sandbox.git Cloning into &#39;workshop_git_for_teams_sandbox&#39;... remote: Enumerating objects: 63, done. remote: Counting objects: 100% (6/6), done. remote: Compressing objects: 100% (3/3), done. remote: Total 63 (delta 5), reused 3 (delta 3), pack-reused 57 Receiving objects: 100% (63/63), 8.00 KiB | 4.00 MiB/s, done. Resolving deltas: 100% (18/18), done. If you’d like, you can use ls to see the newly made directory. You should see something like the following: $ ls Desktop Music Documents Pictures Downloads Public Library workshop_git_for_teams_sandbox Movies If you cd into the directory and then type ls -a, you’ll see a README.md file and a .git file, which contains all the logging info for the repository. $ cd workshop_git_for_teams_sandbox $ ls -a . .. .git .gitignore README.md 5.2 Branching From here, you can start making and tracking changes. But if you’re working with a team, you need to be sure that the changes you make don’t conflict with changes your team members may be making. This is where branching steps in. Version control systems like Git help you avoid major change conflicts (and thus lost or redundant work) by letting you “branch” a repository to complete tasks in parallel with others working on the project. Usually, teams will have a stable, “Main” branch, which serves as an enduring reference point for subsequent modifications. When people want to make changes to that stable code, they’ll make a new copy of the main branch, implement their changes, and then commit their changes back the main one. In a moment, we’ll see how GitHub helps us manage the above process. First, however, we’ll need to branch the repository we’ve just cloned. We’ll do so locally and then we’ll push that branch to the remote repository. First, check whether the cloned repository has any branches with git branch: $ git branch * main Just main so far. Let’s make a new one. Recall that you can make and switch to a new branch with one command: git checkout -b &lt;branch-name&gt; Use this command to branch from the main one. Name your branch with your first name and the first initial of your last name. $ git checkout -b &lt;first-name_last-initial&gt; Switched to a new branch &#39;&lt;first-name_last-initial&gt;&#39; "],["opening-issues-and-making-changes.html", "6 Opening Issues and Making Changes 6.1 About Issues 6.2 Opening an Issue 6.3 Making Changes 6.4 Pushing Changes on a Branch", " 6 Opening Issues and Making Changes You’ve made a branch! It’s now possible to make changes to the cloned repository without stepping on the toes of your team members. However, it would be helpful to communicate with your team and tell them what you’re working on. 6.1 About Issues On GitHub, one of the primary ways we do this is through Issues. Issues are the basic unit of project management on GitHub: they’re used for reporting bugs, keeping track of tasks, and requesting project enhancements. Scope is important for issues: an issue should address a specific bug or a discrete task, which a team member can then work on. Examples might include: Add an “About Us” button to a website navigation bar Following a recent directory restructure, filepaths need to be rewritten Fix the encodings of a source file Update README to include new information about recent changes Issues contain the following parts: A title: a brief summary of the task, bug, or request A description: space for additional information about the task, bug, or request Assignees: information about which team member is working on the issue Labels: projects might ask team members to specify an issue type with a tag (e.g. “bug”, “enhancement”) Milestones: teams can set larger goals for a project, of which a given issue might be a part Comments: space where team members can discuss issues Typically, a team member will open an issue, enter the above information, and begin working on whatever task that issue requires. When they’re finished, the team member will close the issue, which lets others know that that task has been completed. You can read more about GitHub issues here. 6.2 Opening an Issue Before we make any changes to our cloned repository, let’s open an issue. Go to the “Issues” tab at https://github.com/ucdavis-datalab-training/workshop_git_for_teams_sandbox and click the green “New issue” button. It should take you to the following page: You’ll be adding your name to the repository’s README.md file. Your issue’s title should reflect this task. With this information entered, assign yourself to this issue (by clicking the little gear button next to “Assignees”). Then, click the green “Submit new issue” button. GitHub will take you to a new page: 6.3 Making Changes With your issue open, it’s now time to make your changes. In the command line, open the README.md file with Vim. Go to line 12 and enter your first name and the first initial of your last name. The file should look like this: $ cat README.md Practice Repository: Reproducible Research for Teams with GitHub ================================================================ Workshop reader: https://ucdavisdatalab.github.io/workshop_git_for_teams/ Instructions: ------------- Clone this repository, make a new branch named with your first name and last initial (e.g. `first-name_last-initial`) and write your name below. Name: &lt;firstname lastinitial&gt; Save the file and quit Vim. Add the file to the Git staging area with git add. From here, you can commit the file as you normally would. But since you’re working on a specific issue, it would be helpful to reference that issue in your commit message. That way, your team can associate specific changes made to a project with the issues that discuss those changes. GitHub makes tracking issues easier by assigning each issue a number. To reference an issue in a commit, simply type the issue number in the commit message, prepending it with #: $ git add README.md $ git commit -m &#39;adding &lt;your name&gt; to README (resolves #&lt;your issue&gt;) [&lt;first-name_last-initial&gt; e257f92] adding &lt;your name&gt;. to README (resolves #&lt;your issue&gt;) 1 file changed, 1 insertion(+), 1 deletion(-) 6.4 Pushing Changes on a Branch To see how GitHub makes reference to this commit, we’ll need to push our changes. But if you try git push from here, you’ll get the following error message: $ git push fatal: The current branch &lt;first-name_last-initial&gt; has no upstream branch. To push the current branch and set the remote as upstream, use git push --set-upstream origin &lt;first-name_last-initial&gt; Here, Git is telling you that the remote repository doesn’t have a branch to associate your changes with; you’ve made a local branch, but that doesn’t automatically create a remote branch. We can see what branches are available on the remote repository with git branch -a: $ git branch -a main * first-name_last-initial remotes/origin/HEAD -> origin/main remotes/origin/carl_s The text in black lists local branches, while the red text lists remote branches. The “-&gt;” arrow that points from a red remote with a black local tells you which remote branch your own main branch is synced with. From this list, you can see that the remote repository doesn’t have your branch. You’ll need to push it. To do so, type the following into your command line: git push --set-upstream origin &lt;branch-name&gt; There’s also a bit of shorthand for this command: git push -u origin &lt;branch-name&gt; (Note: here “origin” references your local repository.) Once you press “Enter”, you should see something like this: $ git push -u origin &lt;first-name_last-initial&gt; Enumerating objects: 5, done. Counting objects: 100% (5/5), done. Delta compression using up to 12 threads Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 347 bytes | 347.00 KiB/s, done. Total 3 (delta 1), reused 0 (delta 0), pack-reused 0 remote: Resolving deltas: 100% (1/1), completed with 1 local object. remote: remote: Create a pull request for &#39;&lt;first-name_last-initial&gt;&#39; on GitHub by visiting: remote: https://github.com/ucdavis-datalab-training/workshop_git_for_teams_sandbox/pull/new/&lt;first-name_last-initial&gt; remote: To github.com:ucdavis-datalab-training/workshop_git_for_teams_sandbox.git * [new branch] &lt;first-name_last-initial&gt; -&gt; &lt;first-name_last-initial&gt; Branch &#39;&lt;first-name_last-initial&gt;&#39; set up to track remote branch &#39;&lt;first-name_last-initial&gt;&#39; from &#39;origin&#39;. Now, if you type git branch -a, you’ll see a remote copy of your branch. You can also visit the repository page on GitHub, where you’ll see a notice that a branch has “recent pushes”. Click on the “branches” icon: …and you’ll see a list of branches. If you click on yours, you’ll see that this branch is “ahead” of the main branch by 1 commit. You’ll also see that your change has appeared down in the README view. Finally, you’ll see in the commit message view that the message has turned your issue number into a hyperlink. "],["merging-remote-branches.html", "7 Merging Remote Branches 7.1 A Quick Change of Plans 7.2 Tracking a Remote Branch 7.3 Merging Branches 7.4 Closing an Issue", " 7 Merging Remote Branches Clicking on the hyperlink will take you directly to the issue you created. From here, we’re at a crossroads. We could go ahead and implement our changes on the main branch (more about that in a minute) and close out the issue. But there are a lot of participants in the workshop, and all those branches will be a headache to merge seamlessly into main. What we’ll do, then, is implement our changes on only one other remote branch, leaving the main one alone for now. 7.1 A Quick Change of Plans First, on the “branches” page, find another branch with which to merge your own. You should select a branch made by another workshop participant. When you’ve decided on a branch, go to your issue and, in a comment, explain your change of plans. Tag the person whose branch you’ll be merging with using “@”. Click the green “Comment” button. In a real-world project, you might also edit the title of your issue to reflect your changes, but for now, you can leave it as is. 7.2 Tracking a Remote Branch Now it’s time to make a copy of the remote branch on your local computer. You can find the branch on the command line with git branch -a (it’ll be in red text). If you don’t see extra branches listed when you enter this command, run git fetch and try again. There are a few ways to get the branch itself. Newer versions of Git use: $ git switch &lt;remote-branch&gt; Branch &#39;&lt;remote-branch&gt;&#39; set up to track remote branch &#39;&lt;remote-branch&gt;&#39; from &#39;origin&#39;. Switched to a new branch &#39;&lt;remote-branch&gt;&#39; If you have an older version of Git on your computer, you’ll need to use a checkout: $ git checkout &lt;remote-branch&gt; Branch &#39;&lt;remote-branch&gt;&#39; set up to track remote branch &#39;&lt;remote-branch&gt;&#39; from &#39;origin&#39;. Switched to a new branch &#39;&lt;remote-branch&gt;&#39; In either case, Git will pull down a local copy of a remote branch and begin tracking it. Now, if you open the README.md file, you’ll find that your name has disappeared and the other person’s name is there instead. With that, you should now have three branches on your local machine: the main branch, the one you created, and the branch you’ve just fetched from GitHub. 7.3 Merging Branches From here, we can merge branches as we normally would. Switch to your own branch: $ git checkout &lt;first-name_last-initial&gt; Switched to branch &#39;&lt;first-name_last-initial&gt;&#39; Your branch is up to date with &#39;origin/&lt;first-name_last-initial&gt;&#39;. Now, try merge the other branch into your own. You should see an error. $ git merge &lt;other-branch&gt; Auto-merging README.md CONFLICT (content): Merge conflict in README.md Automatic merge failed; fix conflicts and then commit the result. This is because both you and the other person have put your names on the same line. If you open README.md with Vim, or simply cat to screen, you’ll see where the problem is: $ cat README.md Practice Repository: Reproducible Research for Teams with GitHub ================================================================ Workshop reader: https://ucdavisdatalab.github.io/workshop_git_for_teams/ Instructions: ------------- Clone this repository, make a new branch named with your first name and last initial (e.g. `first-name_last-initial`) and write your name below. &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD Name: &lt;your name&gt; ======= Name: &lt;other person&#39;s name&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;other-branch&gt; Fix this conflict by deleting the conflict markers (everything between the &lt;&lt;&lt;&lt;&lt;&lt;&lt; and &gt;&gt;&gt;&gt;&gt;&gt;&gt; marks) and the other person’s changes. Add their name after your own. The file should now look like this: $ cat README.md Practice Repository: Reproducible Research for Teams with GitHub ================================================================ Workshop reader: https://ucdavisdatalab.github.io/workshop_git_for_teams/ Instructions: ------------- Clone this repository, make a new branch named with your first name and last initial (e.g. `first-name_last-initial`) and write your name below. Name: &lt;your name&gt;, &lt;other person&#39;s name&gt; Save and quit Vim. Then, add README.md to your staging area and commit your changes. Your command line should look something like this when you’re done: $ git add README.md $ git commit -m &quot;resolve conflicts with &lt;other person&#39;s&gt; branch&quot; [&lt;first-name_last-initial&gt; 1d00b8f] resolve conflicts with &lt;other person&#39;s&gt; branch If you type git status, you’ll see that your local repository is now ahead of the remote one. $ git status On branch &lt;first-name_last-initial&gt; Your branch is ahead of &#39;origin/&lt;first-name_last-initial&gt;&#39; by 1 commit. (use &quot;git push&quot; to publish your local commits) nothing to commit, working tree clean Go ahead and push your changes. If you go back to GitHub, you should now see the modified README file rendered to the page. 7.4 Closing an Issue Your task is done, so you can close your issue. Return to the “Issues” tab, find your issue, and close it. If you’d like, you can leave a comment when you close. Afterwards, the issue should look like this: "],["open-and-merge-a-pull-request.html", "8 Open and Merge a Pull Request 8.1 Opening a Pull Request 8.2 Merging a Pull Request", " 8 Open and Merge a Pull Request This last part of the workshop will be demo-only. Now that some changes have been made to various branches, we’re going to merge one of those branches back into the main branch using a pull request (the instructor will demo this so that we don’t run into several conflicts). While we could simply merge a branch back into main, a pull request provides a formalized workflow for letting others know that we’re proposing a change. In other words, a pull request is a review process, in which team members can review and discuss changes, make suggestions about how to improve changes or keep changes from breaking other parts of a project, and finally implement changes into a project’s base repository. We won’t go over this much in the workshop itself, but note that many projects let members of the public open pull requests and contribute changes. If, for example, you notice a bug in R’s ggplot2 library and know how to fix it, you could fork the repository into your own GitHub account, make the necessary changes, and then open a pull request for the developers to review. If they accept your changes, your code will be incorporated into the project. 8.1 Opening a Pull Request You can open a pull request by clicking on the “Pull requests” tab. From here, click on the green “New pull request.” Under the “Comparing changes” heading, select two branches from the drop down menus. The branch on the right will be the branch you’re merging into the branch on the left (i.e., the branch on the right is probably the one you’ve been working on). Once you’ve made your selection, GitHub will scan through the branches and identify any differences between them. If the branches are able to be merged, click “Create pull request.” You’ll be taken to a new page, which looks quite similar to the what you’d see if you opened an issue. Just like an issue, a pull request should have a title and a description. You can assign yourself the role of making the request and, if applicable, you can ask someone to review the changes before you implement them (using the “Reviewers” function on the right). Opening a pull request does not automatically implement a merge. Rather, the pull request stays open, providing a space for people to discuss the changes, make revisions if need be, etc. 8.2 Merging a Pull Request Once your team is happy with the changes, and once GitHub has verified that there are no conflicts between the branches, you can click “Merge pull request”. Alternatively, you can merge the pull request on the command line by following the instructions listed below. For our purposes, we’ll just click the button. GitHub will then register that the merge has been made: If you went back to the main page, you’d see that your changes are implemented. From here, you can delete your branch (if you’d like) and then start on the next changes you’d like to make. "],["assessment.html", "9 Assessment", " 9 Assessment To earn GradPathways micro-badge for this workshop, download the zipped assessment folder and unzip it in a location of your choosing on your computer. Follow the included instructions. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
